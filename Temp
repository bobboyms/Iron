

grammar Iron;

// LEXICAL SYMBOLS
DOT: '.' ;
COMMA: ',' ;
PLUS: '+' ;
MINUS: '-' ;
MULT: '*' ;
DIV: '/' ;
EQ: '=' ;
COLON: ':' ; // Adicionado para o caractere ':'
L_PAREN: '(' ;
R_PAREN: ')' ;
L_CURLY: '{' ;
R_CURLY: '}' ;
L_BRACKET: '[' ;
R_BRACKET: ']' ;
PLUS_PLUS: '++' ;
MINUS_MINUS: '--' ;
PIPE: '|' ;
GTEQ: '>=' ;
LTEQ: '<=' ;
GT: '>' ;
LT: '<' ;
DIF: '!=' ;
EQEQ: '==' ;
ARROW: '->' ;

INT_NUMBER: [0-9]+ ;
REAL_NUMBER: [0-9]+ '.' [0-9]+ ;

STRING_LITERAL: '"' (~["\\] | '\\' .)* '"' ;

BOOLEAN_VALUE: 'true' | 'false' ;

IDENTIFIER: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')* ;

WS: [ \t]+ -> skip ;
NEWLINE: '\r'? '\n' ;

COMMENT: '//' ~[\r\n]* -> skip ;
MULTILINE_COMMENT: '/*' .*? '*/' -> skip ;

// Keywords
DO: 'do' ;
FN: 'fn' ;
IF: 'if' ;
OR: 'or' ;
IN: 'in' ;
FOR: 'for' ;
NOT: 'not' ;
AND: 'and' ;
LET: 'let' ;
MUT: 'mut' ;
BREAK: 'break' ;
CONTINUE: 'continue' ;
ELSE: 'else' ;
WHILE: 'while' ;
FOR_EACH: 'forEach' ;
MAP: 'map' ;
FILTER: 'filter' ;
REDUCE: 'reduce' ;
RETURN: 'return' ;
PRINT_LN: 'println' ;
STRUCT: 'struct' ;

// Var Types
TYPE_INT: 'int' ;
TYPE_FLOAT: 'float' ;
TYPE_STRING: 'string' ;
TYPE_BOOLEAN: 'boolean' ;
TYPE_DOUBLE: 'double' ;
TYPE_CHAR: 'char' ;

// Rules
varTypes: TYPE_BOOLEAN | TYPE_CHAR | TYPE_DOUBLE | TYPE_FLOAT | TYPE_INT | TYPE_STRING ;

varDeclaration: LET IDENTIFIER COLON varTypes ('=' (INT_NUMBER | REAL_NUMBER | BOOLEAN_VALUE | STRING_LITERAL))? (NEWLINE | EOF) ;

assignment: IDENTIFIER EQ (INT_NUMBER | REAL_NUMBER | BOOLEAN_VALUE | STRING_LITERAL) (NEWLINE | EOF) ;

program: (varDeclaration | assignment)* EOF ;
